/**
 * Reseplaneraren
 * Provides access to VÃ¤sttrafik journey planner
 *
 * OpenAPI spec version: 1.10.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import io.swagger.client.model.LiveMap;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class LivemapApi {
  String basePath = "https://api.vasttrafik.se/bin/rest.exe/v2";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Returns the positions of all vehicles in a given bounding box
  * This method will return the positions of all vehicles in a given bounding box.
   * @param minx Left border (longitude) of the bounding box in WGS84 * 1000000
   * @param maxx Right border (longitude) of the bounding box in WGS84 * 1000000
   * @param miny Lower border (latitude) of the bounding box in WGS84 * 1000000
   * @param maxy Upper border (latitude) of the bounding box in WGS84 * 1000000
   * @param onlyRealtime Can be used to define whether all vehicles should be returned or only those  vehicles which have realtime information. If it is set to yes, only vehicles  with realtime information are returned, if it is set to no, all vehicles in the  bounding box are returned.
   * @return LiveMap
  */
  public LiveMap livemap (String minx, String maxx, String miny, String maxy, String onlyRealtime) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'minx' is set
    if (minx == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minx' when calling livemap",
        new ApiException(400, "Missing the required parameter 'minx' when calling livemap"));
    }
    // verify the required parameter 'maxx' is set
    if (maxx == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'maxx' when calling livemap",
        new ApiException(400, "Missing the required parameter 'maxx' when calling livemap"));
    }
    // verify the required parameter 'miny' is set
    if (miny == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'miny' when calling livemap",
        new ApiException(400, "Missing the required parameter 'miny' when calling livemap"));
    }
    // verify the required parameter 'maxy' is set
    if (maxy == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'maxy' when calling livemap",
        new ApiException(400, "Missing the required parameter 'maxy' when calling livemap"));
    }
    // verify the required parameter 'onlyRealtime' is set
    if (onlyRealtime == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'onlyRealtime' when calling livemap",
        new ApiException(400, "Missing the required parameter 'onlyRealtime' when calling livemap"));
    }

    // create path and map variables
    String path = "/livemap";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "minx", minx));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "maxx", maxx));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "miny", miny));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "maxy", maxy));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "onlyRealtime", onlyRealtime));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (LiveMap) ApiInvoker.deserialize(localVarResponse, "", LiveMap.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Returns the positions of all vehicles in a given bounding box
   * This method will return the positions of all vehicles in a given bounding box.
   * @param minx Left border (longitude) of the bounding box in WGS84 * 1000000   * @param maxx Right border (longitude) of the bounding box in WGS84 * 1000000   * @param miny Lower border (latitude) of the bounding box in WGS84 * 1000000   * @param maxy Upper border (latitude) of the bounding box in WGS84 * 1000000   * @param onlyRealtime Can be used to define whether all vehicles should be returned or only those  vehicles which have realtime information. If it is set to yes, only vehicles  with realtime information are returned, if it is set to no, all vehicles in the  bounding box are returned.
  */
  public void livemap (String minx, String maxx, String miny, String maxy, String onlyRealtime, final Response.Listener<LiveMap> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'minx' is set
    if (minx == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minx' when calling livemap",
        new ApiException(400, "Missing the required parameter 'minx' when calling livemap"));
    }
    // verify the required parameter 'maxx' is set
    if (maxx == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'maxx' when calling livemap",
        new ApiException(400, "Missing the required parameter 'maxx' when calling livemap"));
    }
    // verify the required parameter 'miny' is set
    if (miny == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'miny' when calling livemap",
        new ApiException(400, "Missing the required parameter 'miny' when calling livemap"));
    }
    // verify the required parameter 'maxy' is set
    if (maxy == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'maxy' when calling livemap",
        new ApiException(400, "Missing the required parameter 'maxy' when calling livemap"));
    }
    // verify the required parameter 'onlyRealtime' is set
    if (onlyRealtime == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'onlyRealtime' when calling livemap",
        new ApiException(400, "Missing the required parameter 'onlyRealtime' when calling livemap"));
    }

    // create path and map variables
    String path = "/livemap".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "minx", minx));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "maxx", maxx));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "miny", miny));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "maxy", maxy));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "onlyRealtime", onlyRealtime));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((LiveMap) ApiInvoker.deserialize(localVarResponse,  "", LiveMap.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
